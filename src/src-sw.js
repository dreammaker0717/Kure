/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { syncCustomersWithDrupal, openMessagesModal, getOrderInfo } from "services/idb_services/customerManager";
import { IDB_TABLES, KureDatabase } from "services/idb_services/KureDatabase";
import { syncOrdersWithDrupal, fetchOrder } from "services/idb_services/orderManager";
import { NetworkFirst } from 'workbox-strategies';
import { convertTimestampToDate } from 'Common/functions';

self.addEventListener('install', event => {
  // Perform installation tasks
  self.skipWaiting()
});

clientsClaim();

/**
 * We are not wrapping it in a 'message' event as per the new update.
 * @see https://developers.google.com/web/tools/workbox/modules/workbox-core
 */
self.skipWaiting();

/**
 * Precache all of the assets generated by your build process.
 * Their URLs are injected into the manifest variable below.
 * This variable must be present somewhere in your service worker file,
 * even if you decide not to use precaching. See https://cra.link/PWA
 */
precacheAndRoute(self.__WB_MANIFEST);

// Set up a route to handle all navigation requests
registerRoute(
  ({ event }) => event.request.mode === 'navigate',
  async ({ event }) => {
    try {
      // Attempt to fetch the requested URL from the network
      return await new NetworkFirst().handle({ event });
    } catch (error) {
      // If the network fails, return the cached index.html file
      return caches.match('/index.html');
    }
  }
);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
// @see https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year.
// @see https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  })
);

registerRoute(
  ({ request }) => request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

/**
 * Listen for push notifications which will come from Drupal.
 */
self.addEventListener('push', async event => {
  console.log('Push event:', event);
  console.log('self :', self);

  try {
    // Access the data payload of the push notification
    const data = JSON.parse(event.data.text());
    const { type, payload } = data;
    console.log('Push data:', data);

    switch (type) {
      case 'notification':
        const { title, body } = payload;
        // Display a notification.
        event.waitUntil(
          self.registration.showNotification(title, {
            body: body,
            icon: './logo.png',
            badge: './logo.png',
            tag: 'notification-1',
            requireInteraction: true,
            actions: [
              {
                action: 'view',
                title: 'View message',
                data: { title, body }
              },
              {
                action: 'dismiss',
                title: 'Dismiss',
              },
            ],
          })
        );

        // Save the notification in our background_messages IDB store. We want to do this in case the user didn't see
        // the notification.
        event.waitUntil(
          self.clients.matchAll().then(async clients => {
            const db = new KureDatabase();
            await db.put([data], IDB_TABLES.background_messages)
          })
        );

        break;
      case 'object_catalog':
        const { object_type, entity_id } = payload;

        if (object_type !== "commerce_order") return;

        const order_response = await fetchOrder(entity_id);
        console.log("order_response == ", order_response);

        if (order_response.length == 0) return;
        if (order_response.state == "completed") return;

        const customer_info = await getOrderInfo(order_response?.customer_id);
        let order_type = order_response.type ? order_response.type.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase()) : 'Delivery';
        let order_state = order_response.state ? order_response.state.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase()) : '';
        let order_time = convertTimestampToDate(order_response.changed);
        let order_id = order_response.order_id;
        let count = order_response.order_items.length;
        let message_title = "A new order from " + customer_info?.name + "\n";
        let message_body = "OrderID: " + order_id + "\nTime: " + order_time + "\nType: " + order_type + "\nState: " + order_state + "\nCount: " + count + " products";

        // If the app is open/closed.
        event.waitUntil(
          self.registration.showNotification(message_title, {
            body: message_body,
            icon: './logo.png',
            badge: './logo.png',
            tag: 'notification-2',
            requireInteraction: true,
            actions: [
              {
                action: 'view',
                title: 'View Order',
                data: { object_type, entity_id }
              },
              {
                action: 'dismiss',
                title: 'Dismiss',
              },
            ],
          }),

          self.clients.matchAll().then(clients => {
            clients.forEach(client => client.postMessage({ type: object_type, entity_id }));
          })
        );
        break;

      default:
        break;
    }
  } catch (e) {
    console.log('Error parsing push notification data: ', e);
  }
});

self.addEventListener('notificationclick', function (event) {
  // Close the notification.
  event.notification.close();
  // Determine which action was clicked.
  if (event.action === 'view') {
    // Open or focus the PWA and navigate to a specific route.
    event.waitUntil(
      self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true,
      }).then(function (clientList) {
        for (var i = 0; i < clientList.length; i++) {
          var client = clientList[i];
          if ('focus' in client) {
            // Focus an existing window.
            client.focus();
            console.log("event", event.notification);
            if (event.notification.tag === "notification-1") {
              const title = event.notification.title;
              const content = event.notification.body;
              const message = { title, content };
              openMessagesModal(message);
            }
            return;
          }
        }
        if (self.clients.openWindow) {
          // Open a new window with a specific route.
          return self.clients.openWindow('/');
        }
      })
    );
  }
});

/**
 * Listen for messages from the client app which need to be sent to the server. This is important
 * because we may need to send data in the background when the device display is off.
 *
 * Note: A background service does not have access to localStorage.
 */
self.addEventListener('sync', function (event) {
  switch (event.tag) {
    case 'customer-data-sync':
      console.log('Syncing customer data: ', event.tag);
      event.waitUntil(syncCustomersWithDrupal());
      break;

    case 'order-data-sync':
      console.log('Syncing order data: ', event.tag);
      event.waitUntil(syncOrdersWithDrupal());
      break;
  }
});
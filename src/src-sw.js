/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { syncCustomersWithDrupal, openMessagesModal, getOrderInfo } from "services/idb_services/customerManager";
import { IDB_TABLES, KureDatabase } from "services/idb_services/KureDatabase";
import { syncOrdersWithDrupal, fetchOrder, notificationForOrders } from "services/idb_services/orderManager";
import { idbGetLoggedInUser } from "services/idb_services/configManager";
import { NetworkFirst } from 'workbox-strategies';
import { convertTimestampToDate } from 'Common/functions';

const cacheName = 'MyFancyCacheName_v1';
let notificationOrderQueue = [];
let timeOutPushNotificationOrder;

const urlsToCache = [
  '/',
  '/index.html',
];

self.addEventListener('install', event => {
  // Perform installation tasks
  event.waitUntil(caches.open(cacheName));
  // event.waitUntil(
  //   caches.open(cacheName).then(cache => {
  //     const cachePromises = urlsToCache.map(url => {
  //       return fetch(url)
  //         .then(response => {
  //           if (!response.ok) {
  //             throw new Error(`Failed to fetch: ${url}`);
  //           }
  //           console.log("---------".response);
  //           console.log("---------".url);
  //           return cache.put(url, response);
  //         })
  //         .catch(error => {
  //           console.error(`Cache add failed for ${url}:`, error);
  //         });
  //     });

  //     return Promise.all(cachePromises);
  //   })
  //     .then(() => {
  //       console.log('Cache add completed.');
  //     })
  //     .catch(error => {
  //       console.error('Cache add operation failed:', error);
  //     })
  // );
  self.skipWaiting()
});

clientsClaim();

/**
 * We are not wrapping it in a 'message' event as per the new update.
 * @see https://developers.google.com/web/tools/workbox/modules/workbox-core
 */
// self.skipWaiting();

/**
 * Precache all of the assets generated by your build process.
 * Their URLs are injected into the manifest variable below.
 * This variable must be present somewhere in your service worker file,
 * even if you decide not to use precaching. See https://cra.link/PWA
 */
precacheAndRoute(self.__WB_MANIFEST);

// Set up a route to handle all navigation requests
// registerRoute(
//   ({ event }) => event.request.mode === 'navigate',
//   async ({ event }) => {
//     try {
//       // Attempt to fetch the requested URL from the network
//       cache.put(event.request, fetchedResponse.clone());
//       return await new NetworkFirst().handle({ event });
//     } catch (error) {
//       // If the network fails, return the cached index.html file
//       return caches.match('/index.html');
//     }
//   }
// );

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
// @see https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year.
// @see https://developers.google.com/web/tools/workbox/guides/common-recipes#google_fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365,
        maxEntries: 30,
      }),
    ],
  })
);

registerRoute(
  ({ request }) => request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Do we really want to cache images?
// registerRoute(
//   ({ request }) => request.destination === 'image' ||
//     request.destination === 'navigate',
//   new StaleWhileRevalidate({
//     cacheName: cacheName,
//   })
// );

// self.addEventListener('fetch', async (event) => {
//   // Is this a request for an image?
//   // if (event.request.destination === 'image') {
//   // Open the cache
//   // event.respondWith(caches.open(cacheName).then((cache) => {
//   //   // Respond with the image from the cache or from the network
//   //   return cache.match(event.request.url).then((cachedResponse) => {
//   //     // Return a cached response if we have one
//   //     if (cachedResponse) {
//   //       return cachedResponse;
//   //     }
//
//   //     // Otherwise, hit the network
//   //     return fetch(event.request).then((fetchedResponse) => {
//   //       // Add the network response to the cache for later visits
//   //       cache.put(event.request, fetchedResponse.clone());
//
//   //       // Return the network response
//   //       return fetchedResponse;
//   //     });
//   //   });
//   // }));
//
//   // if (event.request.mode === 'navigate' || event.request.mode === 'image') {
//   // Open the cache
//   //   event.respondWith(caches.open(cacheName).then((cache) => {
//   //     console.log("cache == ", cache);
//   //     console.log("event.request == ", event.request);
//   //     return cache.match(event.request).then((cachedResponse) => {
//   //       console.log("cachedResponse == ", cachedResponse);
//   //       const fetchedResponse = fetch(event.request).then((networkResponse) => {
//   //         console.log("networkResponse == ", networkResponse);
//   //         cache.put(event.request, networkResponse.clone());
//   //         return networkResponse;
//   //       });
//   //       console.log("fetchedResponse == ", fetchedResponse);
//   //       return cachedResponse || fetchedResponse;
//   //     });
//   //   }));
//   // } else {
//   //   return;
//   // }
//   const requestURL = new URL(event.request.url);
//
//   // Skip caching for requests with 'chrome-extension' scheme
//   if (requestURL.protocol === 'chrome-extension:') {
//     return;
//   }
//
//   event.respondWith(
//     caches.match(event.request).then(cachedResponse => {
//       console.log("cachedResponse == ", cachedResponse);
//       // If the requested resource is in the cache, return it
//       if (cachedResponse) {
//         return cachedResponse;
//       }
//
//       // If the resource is not in the cache, fetch it from the network
//       return fetch(event.request, { redirect: 'follow' }).then(networkResponse => {
//         console.log("networkResponse == ", networkResponse);
//         // Cache the fetched response for future use
//         return caches.open(cacheName).then(cache => {
//           cache.put(event.request, networkResponse.clone());
//           return networkResponse;
//         });
//       });
//     })
//   );
// });

/**
 * Listen for push notifications which will come from Drupal.
 */
self.addEventListener('push', async event => {
  console.log('Push event:', event);
  console.log('self :', self);

  try {
    // Access the data payload of the push notification
    const data = JSON.parse(event.data.text());
    const { type, payload } = data;
    console.log('Push data:', data);
    switch (type) {
      case 'notification':
        const { title, body } = payload;
        // Display a notification.
        event.waitUntil(
          self.registration.showNotification(title, {
            body: body,
            icon: './logo.png',
            badge: './logo.png',
            tag: 'notification-1',
            requireInteraction: true,
            actions: [
              {
                action: 'view',
                title: 'View message',
                data: { title, body }
              },
              {
                action: 'dismiss',
                title: 'Dismiss',
              },
            ],
          })
        );

        // Save the notification in our background_messages IDB store. We want to do this in case the user didn't see
        // the notification.
        event.waitUntil(
          self.clients.matchAll().then(async clients => {
            const db = new KureDatabase();
            await db.put([data], IDB_TABLES.background_messages)
          })
        );

        break;
      case 'object_catalog':
        const { object_type, entity_id } = payload;

        if (object_type == "commerce_order") {
          let user_info = await idbGetLoggedInUser();
          const isEmployee = user_info?.roles?.includes("administrator") ?? false;

          if (isEmployee) {
            notificationForOrder(payload, event);
          } else {
            let foundObject = notificationOrderQueue.find(obj => obj.entity_id === entity_id);
            if (!foundObject) {
              notificationOrderQueue.push(payload);
              clearTimeout(timeOutPushNotificationOrder);
            }

            timeOutPushNotificationOrder = setTimeout(() => {
              if (notificationOrderQueue.length == 1) {
                notificationForOrder(notificationOrderQueue[0], event);
              } else {
                notificationForOrders(notificationOrderQueue);
              }
              notificationOrderQueue = [];
            }, 5000);
          }
        }

        // If the app is open/closed.
        // event.waitUntil(
        //   self.clients.matchAll({
        //     type: 'window',
        //     includeUncontrolled: true,
        //   }).then(clients => {
        //     if ('focus' in clients) {
        //       clients.forEach(client.postMessage({ type: object_type, entity_id }));
        //     }
        //   })
        // );

        // It's important that this block of code isn't touched. Do not place this into a condition. It must always run.
        // This is responsible for sending a message to different parts of the app. For example, if we receive data for
        // an entity type of 'product_data' or 'user' or 'adjustment', etc.. we need this code to run.
        // event.waitUntil(
        //   self.clients.matchAll().then(clients => {
        //     clients.forEach(client => client.postMessage({ type: object_type, entity_id }));
        //   })
        // );
        event.waitUntil(
          self.clients.matchAll().then(clients => {
            return Promise.all(clients.map(client => {
              return client.postMessage({ type: payload.object_type, entity_id: payload.entity_id });
            }));
          }))
        break;

      default:
        break;
    }
  } catch (e) {
    console.log('Error parsing push notification data: ', e);
  }
});

self.addEventListener('notificationclick', function (event) {
  // Close the notification.
  event.notification.close();
  // Determine which action was clicked.
  if (event.action === 'view') {
    // Open or focus the PWA and navigate to a specific route.
    event.waitUntil(
      self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true,
      }).then(function (clientList) {
        for (var i = 0; i < clientList.length; i++) {
          var client = clientList[i];
          if ('focus' in client) {
            // Focus an existing window.
            client.focus();
            console.log("event-->", event.notification);
            if (event.notification.tag === "notification-1") {
              const title = event.notification.title;
              const content = event.notification.body;
              const message = { title, content };
              openMessagesModal(message);
            }
            return;
          }
        }
        if (self.clients.openWindow) {
          // Open a new window with a specific route.
          return self.clients.openWindow('/');
        }
      })
    );
  }
});


self.addEventListener('message', event => {
  // Perform your background task here
  // For example, a loop that sends a message every second
  setInterval(() => {
    self.postMessage('Background task is running...');
  }, 2000);
});

/**
 * Listen for messages from the client app which need to be sent to the server. This is important
 * because we may need to send data in the background when the device display is off.
 *
 * Note: A background service does not have access to localStorage.
 */
self.addEventListener('sync', function (event) {
  switch (event.tag) {
    case 'customer-data-sync':
      console.log('Syncing customer data: ', event.tag);
      event.waitUntil(syncCustomersWithDrupal());
      break;

    case 'order-data-sync':
      console.log('Syncing order data: ', event.tag);
      event.waitUntil(syncOrdersWithDrupal());
      break;
  }
});



const notificationForOrder = async (payload, event) => {
  const { object_type, entity_id } = payload;
  // Implement your logic to generate the notification using the data
  // Example: displaying the notification

  const order_response = await fetchOrder(entity_id);
  console.log("order_response == ", order_response);

  if (order_response.length !== 0 && order_response.state === "needs_processing") {
    //const customer_info = await getOrderInfo(order_response?.customer_id);
    let order_type = order_response.type ? order_response.type.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase()) : 'Delivery';
    let order_state = order_response.state ? order_response.state.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase()) : '';
    let order_time = convertTimestampToDate(order_response.changed);
    let order_id = order_response.order_id;
    let count = 0;
    if (order_response.order_items !== undefined) {
      for (let i = 0; i < order_response.order_items.length; i++) {
        const order_item = order_response.order_items[i];
        // We can't assume order quantities will always be a whole number. Don't use parseInt().
        count += parseFloat(order_item.quantity);
      }
    }

    let message_title = "An order (" + order_state + ")\n";
    let message_body = "Order ID: " + order_id + "\nTime: " + order_time + "\nType: " + order_type + "\nCount: " + count + " products";

    event.waitUntil(
      self.registration.showNotification(message_title, {
        body: message_body,
        icon: './logo.png',
        badge: './logo.png',
        tag: 'notification-2',
        requireInteraction: true,
        silent: true,
        actions: [
          {
            action: 'view',
            title: 'View Order',
            data: { object_type, entity_id }
          },
          {
            action: 'dismiss',
            title: 'Dismiss',
          },
        ],
      })
    );
  }
}